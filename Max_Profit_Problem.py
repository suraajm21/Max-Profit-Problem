# We define a function that will compute the maximum profit
# possible for a given total number of available time units.
def solve_max_profit(time_units):

    # Create a DP array where dp[t] will store the maximum profit
    # achievable using exactly t time units.
    dp = [0] * (time_units + 1)

    # Initialize the solution tracker.
    # We create a list of dictionaries to track exactly which buildings make up the best profit for each time unit.
    # This ensures that when we find the max profit, we also know the specific mix (e.g., 2 Theatres) 
    # that created it.
    solution = [{"T": 0, "P": 0, "C": 0} for _ in range(time_units + 1)]

    # Define the building constants based on the problem statement.
    # We store the Name, Build Cost (time needed), and Earning Rate for each type.
    # This allows us to easily loop through them later without hardcoding values inside the logic.
    buildings = [
        {"name": "T", "cost": 5, "earn": 1500},   # Theatre
        {"name": "P", "cost": 4, "earn": 1000},   # Pub
        {"name": "C", "cost": 10, "earn": 2000}   # Commercial Park
    ]

    # Start the main loop to solve the problem for every time unit from 1 to 'time_units'.
    # We solve the problem incrementally: first finding the best profit for time=1, then time=2, etc.
    # This build-up allows us to reuse the answers from smaller time units to solve larger ones.
    for t in range(1, time_units + 1):

        # Iterate through each building type (Theatre, Pub, Commercial Park).
        # At every specific time 't', we check if building each of these options is valid and profitable.
        for b in buildings:

            # Get how long this building takes to build.
            cost = b["cost"]

            # Get how much money this building earns per time unit.
            earn = b["earn"]

            # Check if we actually have enough time to build this building.
            # If the current time 't' is less than the build cost, we skip it because it's impossible to build.
            if t >= cost:

                # Calculate the profit generated by THIS specific building instance.
                # Profit = (Operational Time) * Rate.
                # Operational Time is the total time 't' minus the time spent building it ('cost').
                current_building_profit = (t - cost) * earn

                # Calculate the total potential profit for this scenario.
                # We take the profit from this new building and add it to the max profit we found for the 
                # REMAINING time units (t - cost).
                total_profit = current_building_profit + dp[t - cost]

                # Compare this new total profit against the current best profit recorded for time 't'.
                # If this new combination yields more money, we update dp[t] and store the corresponding building mix.
                if total_profit > dp[t]:

                    # Update the DP table with the new maximum profit for time t.
                    # This effectively "saves" this new high score so it can be used for future calculations.
                    dp[t] = total_profit

                    # We copy the best building mix from remaining time (t - cost),
                    # because we are extending that solution by adding this building.
                    solution[t] = solution[t - cost].copy()

                    # Add the current building to the building mix.
                    solution[t][b["name"]] += 1

    # dp[time_units] gives the max money, and solution[time_units] gives the building counts.
    # After filling dp[] and solution[], return the best profit and building mix 
    # for the full amount of time (time_units).
    return dp[time_units], solution[time_units]


# Define the test cases we want to run (given in the problem statement).
tests = [7, 8, 13]

# Loop through each test case to verify the algorithm works correctly and run the DP solution.
for t in tests:

    # Run the function for the current test case 't'.
    # Compute the maximum earnings and the building mix for this time value.
    earnings, mix = solve_max_profit(t)

    # Print the time value, the maximum earnings, and the number of each building used.
    print(f"Time Unit: {t} | Earnings: ${earnings} | Solution: T:{mix['T']} P:{mix['P']} C:{mix['C']}")
